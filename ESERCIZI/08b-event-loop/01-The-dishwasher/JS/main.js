/**
 * @file        main.js
 * @author      Gabriele Speciale
 * @date        2024-05-26
 * @description 
 * Create a simulation of a dishwasher system using two stacks of dishes
    ‚óè one stack represents dirty dishes, and the other represents clean dishes
    ‚óè the dirty stack has a random number of plates 10 - 50
    ‚óè useful functions
     ‚óã washDish - moves a dish from the dirty stack to the clean stack
     ‚óã displayStacks - displays the current state of both stacks in the console
     ‚óã runSimulation - simulate washing all dirty dishes adding a random delay between steps
 */

const min_piatti = 10;
const max_piatti = 50;

/**
 * function createDirtyStack
 * 
 * will create and insert with .push(), a random number of elements (string) inside of
 * of the stack of dirty dishes ( 10 - 50 plates )
 * @returns {object} - Array containing dirty dishes (everyone is numbered)
 */
function createDirtyStack() {
    let platesDirty = [];
    let randomPlates = Math.round(Math.random() * (max_piatti - min_piatti) + min_piatti);

    for (let i = 0; i < randomPlates; i++) {
        platesDirty.push(`plates number ${i + 1}`);
    }

    return platesDirty;
}




/**
 * function displayStacks
 * 
 * The situation of the dishes will be printed at each interval, which dishes are still
 * present in the stack of the dirty dishes, and how many have been put in the stack of the clean dishes
 * @param {object} stackCleanPlates - Array containing the clean dishes
 * @param {object} stackDirtyPlates - Array containing the clean dishes
 */
function displayStacks(stackCleanPlates, stackDirtyPlates) {

    console.clear();

    console.log(`STACK OF DIRTY PLATES üçΩüí©:
${stackDirtyPlates.join("\n")}\n\n\n\n\nSTACK OF CLEAN PLATESüçΩ:
${stackCleanPlates.join("\n")}`);


    if (stackDirtyPlates.length === 0) {
        console.log("\n\n! U CLEAN ALL THE PLATES !")
    }
}




/**
 * function washDish
 * 
 * If in the stack of dirty dishes, there are still dishes, then let's go to:
 * REMOVE the last element of array trough .pop() (that is, the dish at the top of the stack), 
 * And let's go to INSERT the dish raised before, inside the array of the stack containing the clean dishes trough .push()
 * @param {object} stackCleanPlates - Array containing the clean dishes
 * @param {object} stackDirtyPlates - Array containing the clean dishes
 */
function washDish(stackCleanPlates, stackDirtyPlates) {

    stackCleanPlates.push(stackDirtyPlates.pop());
}



/**
 * function runSimulation
 * 
 * Every 2 seconds whit the setInterval() he comes:
 *  1. the trend of the remaining dirty dishes and the already clean dishes.
 *  2. After that through the function washDish(), will go to get the last dish
 *     of the stack of dirty dishes, and we will insert it into the stack of clean dishes in growing order
 * 
 * If the length of the array (dirtyPlates.length) is === 0,:
 *  1. We will go to print the situation that will be for the last time: 
 *     All dishes have been clean and there will be no dirty dish
 *  2. we stop the interval through the clearInterval()
 * 
 * for all the functions, we pass as argument the stack of dirty plates and the stack of the clean plates
 */
function runSimulation() {

    // stack (array), containing dirty dishes randomly generated by the function createDirtyStack()
    const stackDirtyPlates = createDirtyStack();

    // stack (array), containing clean dishes
    const stackCleanPlates = [];

    let timerId = setInterval(() => {

         // Display the current state of the stacks
        displayStacks(stackCleanPlates, stackDirtyPlates);

          // Check if all dirty stacks are empty
        if (stackDirtyPlates.length === 0) {
            clearInterval(timerId);

        } else {  
            washDish(stackCleanPlates, stackDirtyPlates);

        }

    }, 2000);
}






// Let's start washing the dishes!
runSimulation();